# Troubleshooting Guide

This guide helps resolve common issues encountered when using AutoCSV Profiler.

## Quick Diagnosis

### Problem Categories

<img src="data:image/svg+xml;base64,PHN2ZyBhcmlhLXJvbGVkZXNjcmlwdGlvbj0iZmxvd2NoYXJ0LXYyIiByb2xlPSJncmFwaGljcy1kb2N1bWVudCBkb2N1bWVudCIgdmlld0JveD0iMCAwIDI1MTEuODI4MTI1IDUwMy42MDkzNzUiIHN0eWxlPSJtYXgtd2lkdGg6IDI1MTEuODNweDsgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7IiBjbGFzcz0iZmxvd2NoYXJ0IiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB3aWR0aD0iMTAwJSIgaWQ9Im15LXN2ZyI+PHN0eWxlPiNteS1zdmd7Zm9udC1mYW1pbHk6InRyZWJ1Y2hldCBtcyIsdmVyZGFuYSxhcmlhbCxzYW5zLXNlcmlmO2ZvbnQtc2l6ZToxNnB4O2ZpbGw6IzMzMzt9QGtleWZyYW1lcyBlZGdlLWFuaW1hdGlvbi1mcmFtZXtmcm9te3N0cm9rZS1kYXNob2Zmc2V0OjA7fX1Aa2V5ZnJhbWVzIGRhc2h7dG97c3Ryb2tlLWRhc2hvZmZzZXQ6MDt9fSNteS1zdmcgLmVkZ2UtYW5pbWF0aW9uLXNsb3d7c3Ryb2tlLWRhc2hhcnJheTo5LDUhaW1wb3J0YW50O3N0cm9rZS1kYXNob2Zmc2V0OjkwMDthbmltYXRpb246ZGFzaCA1MHMgbGluZWFyIGluZmluaXRlO3N0cm9rZS1saW5lY2FwOnJvdW5kO30jbXktc3ZnIC5lZGdlLWFuaW1hdGlvbi1mYXN0e3N0cm9rZS1kYXNoYXJyYXk6OSw1IWltcG9ydGFudDtzdHJva2UtZGFzaG9mZnNldDo5MDA7YW5pbWF0aW9uOmRhc2ggMjBzIGxpbmVhciBpbmZpbml0ZTtzdHJva2UtbGluZWNhcDpyb3VuZDt9I215LXN2ZyAuZXJyb3ItaWNvbntmaWxsOiM1NTIyMjI7fSNteS1zdmcgLmVycm9yLXRleHR7ZmlsbDojNTUyMjIyO3N0cm9rZTojNTUyMjIyO30jbXktc3ZnIC5lZGdlLXRoaWNrbmVzcy1ub3JtYWx7c3Ryb2tlLXdpZHRoOjFweDt9I215LXN2ZyAuZWRnZS10aGlja25lc3MtdGhpY2t7c3Ryb2tlLXdpZHRoOjMuNXB4O30jbXktc3ZnIC5lZGdlLXBhdHRlcm4tc29saWR7c3Ryb2tlLWRhc2hhcnJheTowO30jbXktc3ZnIC5lZGdlLXRoaWNrbmVzcy1pbnZpc2libGV7c3Ryb2tlLXdpZHRoOjA7ZmlsbDpub25lO30jbXktc3ZnIC5lZGdlLXBhdHRlcm4tZGFzaGVke3N0cm9rZS1kYXNoYXJyYXk6Mzt9I215LXN2ZyAuZWRnZS1wYXR0ZXJuLWRvdHRlZHtzdHJva2UtZGFzaGFycmF5OjI7fSNteS1zdmcgLm1hcmtlcntmaWxsOiMzMzMzMzM7c3Ryb2tlOiMzMzMzMzM7fSNteS1zdmcgLm1hcmtlci5jcm9zc3tzdHJva2U6IzMzMzMzMzt9I215LXN2ZyBzdmd7Zm9udC1mYW1pbHk6InRyZWJ1Y2hldCBtcyIsdmVyZGFuYSxhcmlhbCxzYW5zLXNlcmlmO2ZvbnQtc2l6ZToxNnB4O30jbXktc3ZnIHB7bWFyZ2luOjA7fSNteS1zdmcgLmxhYmVse2ZvbnQtZmFtaWx5OiJ0cmVidWNoZXQgbXMiLHZlcmRhbmEsYXJpYWwsc2Fucy1zZXJpZjtjb2xvcjojMzMzO30jbXktc3ZnIC5jbHVzdGVyLWxhYmVsIHRleHR7ZmlsbDojMzMzO30jbXktc3ZnIC5jbHVzdGVyLWxhYmVsIHNwYW57Y29sb3I6IzMzMzt9I215LXN2ZyAuY2x1c3Rlci1sYWJlbCBzcGFuIHB7YmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudDt9I215LXN2ZyAubGFiZWwgdGV4dCwjbXktc3ZnIHNwYW57ZmlsbDojMzMzO2NvbG9yOiMzMzM7fSNteS1zdmcgLm5vZGUgcmVjdCwjbXktc3ZnIC5ub2RlIGNpcmNsZSwjbXktc3ZnIC5ub2RlIGVsbGlwc2UsI215LXN2ZyAubm9kZSBwb2x5Z29uLCNteS1zdmcgLm5vZGUgcGF0aHtmaWxsOiNFQ0VDRkY7c3Ryb2tlOiM5MzcwREI7c3Ryb2tlLXdpZHRoOjFweDt9I215LXN2ZyAucm91Z2gtbm9kZSAubGFiZWwgdGV4dCwjbXktc3ZnIC5ub2RlIC5sYWJlbCB0ZXh0LCNteS1zdmcgLmltYWdlLXNoYXBlIC5sYWJlbCwjbXktc3ZnIC5pY29uLXNoYXBlIC5sYWJlbHt0ZXh0LWFuY2hvcjptaWRkbGU7fSNteS1zdmcgLm5vZGUgLmthdGV4IHBhdGh7ZmlsbDojMDAwO3N0cm9rZTojMDAwO3N0cm9rZS13aWR0aDoxcHg7fSNteS1zdmcgLnJvdWdoLW5vZGUgLmxhYmVsLCNteS1zdmcgLm5vZGUgLmxhYmVsLCNteS1zdmcgLmltYWdlLXNoYXBlIC5sYWJlbCwjbXktc3ZnIC5pY29uLXNoYXBlIC5sYWJlbHt0ZXh0LWFsaWduOmNlbnRlcjt9I215LXN2ZyAubm9kZS5jbGlja2FibGV7Y3Vyc29yOnBvaW50ZXI7fSNteS1zdmcgLnJvb3QgLmFuY2hvciBwYXRoe2ZpbGw6IzMzMzMzMyFpbXBvcnRhbnQ7c3Ryb2tlLXdpZHRoOjA7c3Ryb2tlOiMzMzMzMzM7fSNteS1zdmcgLmFycm93aGVhZFBhdGh7ZmlsbDojMzMzMzMzO30jbXktc3ZnIC5lZGdlUGF0aCAucGF0aHtzdHJva2U6IzMzMzMzMztzdHJva2Utd2lkdGg6Mi4wcHg7fSNteS1zdmcgLmZsb3djaGFydC1saW5re3N0cm9rZTojMzMzMzMzO2ZpbGw6bm9uZTt9I215LXN2ZyAuZWRnZUxhYmVse2JhY2tncm91bmQtY29sb3I6cmdiYSgyMzIsMjMyLDIzMiwgMC44KTt0ZXh0LWFsaWduOmNlbnRlcjt9I215LXN2ZyAuZWRnZUxhYmVsIHB7YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDIzMiwyMzIsMjMyLCAwLjgpO30jbXktc3ZnIC5lZGdlTGFiZWwgcmVjdHtvcGFjaXR5OjAuNTtiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMjMyLDIzMiwyMzIsIDAuOCk7ZmlsbDpyZ2JhKDIzMiwyMzIsMjMyLCAwLjgpO30jbXktc3ZnIC5sYWJlbEJrZ3tiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMjMyLCAyMzIsIDIzMiwgMC41KTt9I215LXN2ZyAuY2x1c3RlciByZWN0e2ZpbGw6I2ZmZmZkZTtzdHJva2U6I2FhYWEzMztzdHJva2Utd2lkdGg6MXB4O30jbXktc3ZnIC5jbHVzdGVyIHRleHR7ZmlsbDojMzMzO30jbXktc3ZnIC5jbHVzdGVyIHNwYW57Y29sb3I6IzMzMzt9I215LXN2ZyBkaXYubWVybWFpZFRvb2x0aXB7cG9zaXRpb246YWJzb2x1dGU7dGV4dC1hbGlnbjpjZW50ZXI7bWF4LXdpZHRoOjIwMHB4O3BhZGRpbmc6MnB4O2ZvbnQtZmFtaWx5OiJ0cmVidWNoZXQgbXMiLHZlcmRhbmEsYXJpYWwsc2Fucy1zZXJpZjtmb250LXNpemU6MTJweDtiYWNrZ3JvdW5kOmhzbCg4MCwgMTAwJSwgOTYuMjc0NTA5ODAzOSUpO2JvcmRlcjoxcHggc29saWQgI2FhYWEzMztib3JkZXItcmFkaXVzOjJweDtwb2ludGVyLWV2ZW50czpub25lO3otaW5kZXg6MTAwO30jbXktc3ZnIC5mbG93Y2hhcnRUaXRsZVRleHR7dGV4dC1hbmNob3I6bWlkZGxlO2ZvbnQtc2l6ZToxOHB4O2ZpbGw6IzMzMzt9I215LXN2ZyByZWN0LnRleHR7ZmlsbDpub25lO3N0cm9rZS13aWR0aDowO30jbXktc3ZnIC5pY29uLXNoYXBlLCNteS1zdmcgLmltYWdlLXNoYXBle2JhY2tncm91bmQtY29sb3I6cmdiYSgyMzIsMjMyLDIzMiwgMC44KTt0ZXh0LWFsaWduOmNlbnRlcjt9I215LXN2ZyAuaWNvbi1zaGFwZSBwLCNteS1zdmcgLmltYWdlLXNoYXBlIHB7YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDIzMiwyMzIsMjMyLCAwLjgpO3BhZGRpbmc6MnB4O30jbXktc3ZnIC5pY29uLXNoYXBlIHJlY3QsI215LXN2ZyAuaW1hZ2Utc2hhcGUgcmVjdHtvcGFjaXR5OjAuNTtiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMjMyLDIzMiwyMzIsIDAuOCk7ZmlsbDpyZ2JhKDIzMiwyMzIsMjMyLCAwLjgpO30jbXktc3ZnIC5sYWJlbC1pY29ue2Rpc3BsYXk6aW5saW5lLWJsb2NrO2hlaWdodDoxZW07b3ZlcmZsb3c6dmlzaWJsZTt2ZXJ0aWNhbC1hbGlnbjotMC4xMjVlbTt9I215LXN2ZyAubm9kZSAubGFiZWwtaWNvbiBwYXRoe2ZpbGw6Y3VycmVudENvbG9yO3N0cm9rZTpyZXZlcnQ7c3Ryb2tlLXdpZHRoOnJldmVydDt9I215LXN2ZyA6cm9vdHstLW1lcm1haWQtZm9udC1mYW1pbHk6InRyZWJ1Y2hldCBtcyIsdmVyZGFuYSxhcmlhbCxzYW5zLXNlcmlmO308L3N0eWxlPjxnPjxtYXJrZXIgb3JpZW50PSJhdXRvIiBtYXJrZXJIZWlnaHQ9IjgiIG1hcmtlcldpZHRoPSI4IiBtYXJrZXJVbml0cz0idXNlclNwYWNlT25Vc2UiIHJlZlk9IjUiIHJlZlg9IjUiIHZpZXdCb3g9IjAgMCAxMCAxMCIgY2xhc3M9Im1hcmtlciBmbG93Y2hhcnQtdjIiIGlkPSJteS1zdmdfZmxvd2NoYXJ0LXYyLXBvaW50RW5kIj48cGF0aCBzdHlsZT0ic3Ryb2tlLXdpZHRoOiAxOyBzdHJva2UtZGFzaGFycmF5OiAxLCAwOyIgY2xhc3M9ImFycm93TWFya2VyUGF0aCIgZD0iTSAwIDAgTCAxMCA1IEwgMCAxMCB6Ii8+PC9tYXJrZXI+PG1hcmtlciBvcmllbnQ9ImF1dG8iIG1hcmtlckhlaWdodD0iOCIgbWFya2VyV2lkdGg9IjgiIG1hcmtlclVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgcmVmWT0iNSIgcmVmWD0iNC41IiB2aWV3Qm94PSIwIDAgMTAgMTAiIGNsYXNzPSJtYXJrZXIgZmxvd2NoYXJ0LXYyIiBpZD0ibXktc3ZnX2Zsb3djaGFydC12Mi1wb2ludFN0YXJ0Ij48cGF0aCBzdHlsZT0ic3Ryb2tlLXdpZHRoOiAxOyBzdHJva2UtZGFzaGFycmF5OiAxLCAwOyIgY2xhc3M9ImFycm93TWFya2VyUGF0aCIgZD0iTSAwIDUgTCAxMCAxMCBMIDEwIDAgeiIvPjwvbWFya2VyPjxtYXJrZXIgb3JpZW50PSJhdXRvIiBtYXJrZXJIZWlnaHQ9IjExIiBtYXJrZXJXaWR0aD0iMTEiIG1hcmtlclVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgcmVmWT0iNSIgcmVmWD0iMTEiIHZpZXdCb3g9IjAgMCAxMCAxMCIgY2xhc3M9Im1hcmtlciBmbG93Y2hhcnQtdjIiIGlkPSJteS1zdmdfZmxvd2NoYXJ0LXYyLWNpcmNsZUVuZCI+PGNpcmNsZSBzdHlsZT0ic3Ryb2tlLXdpZHRoOiAxOyBzdHJva2UtZGFzaGFycmF5OiAxLCAwOyIgY2xhc3M9ImFycm93TWFya2VyUGF0aCIgcj0iNSIgY3k9IjUiIGN4PSI1Ii8+PC9tYXJrZXI+PG1hcmtlciBvcmllbnQ9ImF1dG8iIG1hcmtlckhlaWdodD0iMTEiIG1hcmtlcldpZHRoPSIxMSIgbWFya2VyVW5pdHM9InVzZXJTcGFjZU9uVXNlIiByZWZZPSI1IiByZWZYPSItMSIgdmlld0JveD0iMCAwIDEwIDEwIiBjbGFzcz0ibWFya2VyIGZsb3djaGFydC12MiIgaWQ9Im15LXN2Z19mbG93Y2hhcnQtdjItY2lyY2xlU3RhcnQiPjxjaXJjbGUgc3R5bGU9InN0cm9rZS13aWR0aDogMTsgc3Ryb2tlLWRhc2hhcnJheTogMSwgMDsiIGNsYXNzPSJhcnJvd01hcmtlclBhdGgiIHI9IjUiIGN5PSI1IiBjeD0iNSIvPjwvbWFya2VyPjxtYXJrZXIgb3JpZW50PSJhdXRvIiBtYXJrZXJIZWlnaHQ9IjExIiBtYXJrZXJXaWR0aD0iMTEiIG1hcmtlclVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgcmVmWT0iNS4yIiByZWZYPSIxMiIgdmlld0JveD0iMCAwIDExIDExIiBjbGFzcz0ibWFya2VyIGNyb3NzIGZsb3djaGFydC12MiIgaWQ9Im15LXN2Z19mbG93Y2hhcnQtdjItY3Jvc3NFbmQiPjxwYXRoIHN0eWxlPSJzdHJva2Utd2lkdGg6IDI7IHN0cm9rZS1kYXNoYXJyYXk6IDEsIDA7IiBjbGFzcz0iYXJyb3dNYXJrZXJQYXRoIiBkPSJNIDEsMSBsIDksOSBNIDEwLDEgbCAtOSw5Ii8+PC9tYXJrZXI+PG1hcmtlciBvcmllbnQ9ImF1dG8iIG1hcmtlckhlaWdodD0iMTEiIG1hcmtlcldpZHRoPSIxMSIgbWFya2VyVW5pdHM9InVzZXJTcGFjZU9uVXNlIiByZWZZPSI1LjIiIHJlZlg9Ii0xIiB2aWV3Qm94PSIwIDAgMTEgMTEiIGNsYXNzPSJtYXJrZXIgY3Jvc3MgZmxvd2NoYXJ0LXYyIiBpZD0ibXktc3ZnX2Zsb3djaGFydC12Mi1jcm9zc1N0YXJ0Ij48cGF0aCBzdHlsZT0ic3Ryb2tlLXdpZHRoOiAyOyBzdHJva2UtZGFzaGFycmF5OiAxLCAwOyIgY2xhc3M9ImFycm93TWFya2VyUGF0aCIgZD0iTSAxLDEgbCA5LDkgTSAxMCwxIGwgLTksOSIvPjwvbWFya2VyPjxnIGNsYXNzPSJyb290Ij48ZyBjbGFzcz0iY2x1c3RlcnMiLz48ZyBjbGFzcz0iZWRnZVBhdGhzIj48cGF0aCBtYXJrZXItZW5kPSJ1cmwoI215LXN2Z19mbG93Y2hhcnQtdjItcG9pbnRFbmQpIiBzdHlsZT0iIiBjbGFzcz0iZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGZsb3djaGFydC1saW5rIiBpZD0iTF9BX0JfMCIgZD0iTTE0MjcuMDM5LDYyTDE0MjcuMDM5LDY2LjE2N0MxNDI3LjAzOSw3MC4zMzMsMTQyNy4wMzksNzguNjY3LDE0MjcuMTA5LDg2LjQxN0MxNDI3LjE4LDk0LjE2NywxNDI3LjMyLDEwMS4zMzQsMTQyNy4zOSwxMDQuOTE3TDE0MjcuNDYxLDEwOC41MDEiLz48cGF0aCBtYXJrZXItZW5kPSJ1cmwoI215LXN2Z19mbG93Y2hhcnQtdjItcG9pbnRFbmQpIiBzdHlsZT0iIiBjbGFzcz0iZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGZsb3djaGFydC1saW5rIiBpZD0iTF9CX0NfMCIgZD0iTTEzNDcuMzQ4LDIwNy45MTlMMTE2Mi42MjIsMjI1LjM2N0M5NzcuODk2LDI0Mi44MTYsNjA4LjQ0NCwyNzcuNzEzLDQyMy43MTgsMjk4LjY2MUMyMzguOTkyLDMxOS42MDksMjM4Ljk5MiwzMjYuNjA5LDIzOC45OTIsMzMwLjEwOUwyMzguOTkyLDMzMy42MDkiLz48cGF0aCBtYXJrZXItZW5kPSJ1cmwoI215LXN2Z19mbG93Y2hhcnQtdjItcG9pbnRFbmQpIiBzdHlsZT0iIiBjbGFzcz0iZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGZsb3djaGFydC1saW5rIiBpZD0iTF9CX0RfMCIgZD0iTTEzNTMuODY0LDIxNC40MzVMMTI2OC4wMywyMzAuNzk3QzExODIuMTk2LDI0Ny4xNTksMTAxMC41MjgsMjc5Ljg4NCw5MjQuNjk0LDI5OS43NDdDODM4Ljg1OSwzMTkuNjA5LDgzOC44NTksMzI2LjYwOSw4MzguODU5LDMzMC4xMDlMODM4Ljg1OSwzMzMuNjA5Ii8+PHBhdGggbWFya2VyLWVuZD0idXJsKCNteS1zdmdfZmxvd2NoYXJ0LXYyLXBvaW50RW5kKSIgc3R5bGU9IiIgY2xhc3M9ImVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBmbG93Y2hhcnQtbGluayIgaWQ9IkxfQl9FXzAiIGQ9Ik0xNDI3LjUzOSwyODguMTA5TDE0MjcuNDU2LDI5Mi4xOTNDMTQyNy4zNzIsMjk2LjI3NiwxNDI3LjIwNiwzMDQuNDQzLDE0MjcuMTIyLDMxMi4wMjZDMTQyNy4wMzksMzE5LjYwOSwxNDI3LjAzOSwzMjYuNjA5LDE0MjcuMDM5LDMzMC4xMDlMMTQyNy4wMzksMzMzLjYwOSIvPjxwYXRoIG1hcmtlci1lbmQ9InVybCgjbXktc3ZnX2Zsb3djaGFydC12Mi1wb2ludEVuZCkiIHN0eWxlPSIiIGNsYXNzPSJlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZmxvd2NoYXJ0LWxpbmsiIGlkPSJMX0JfRl8wIiBkPSJNMTQ5Ny45OTksMjE3LjY1TDE1NjIuNTQ0LDIzMy40NzZDMTYyNy4wOSwyNDkuMzAzLDE3NTYuMTgyLDI4MC45NTYsMTgyMC43MjgsMzAwLjI4M0MxODg1LjI3MywzMTkuNjA5LDE4ODUuMjczLDMyNi42MDksMTg4NS4yNzMsMzMwLjEwOUwxODg1LjI3MywzMzMuNjA5Ii8+PHBhdGggbWFya2VyLWVuZD0idXJsKCNteS1zdmdfZmxvd2NoYXJ0LXYyLXBvaW50RW5kKSIgc3R5bGU9IiIgY2xhc3M9ImVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBmbG93Y2hhcnQtbGluayIgaWQ9IkxfQl9HXzAiIGQ9Ik0xNTA1LjYzMSwyMTAuMDE3TDE2NDMuNjk1LDIyNy4xMTZDMTc4MS43NTgsMjQ0LjIxNSwyMDU3Ljg4NSwyNzguNDEyLDIxOTUuOTQ4LDI5OS4wMTFDMjMzNC4wMTIsMzE5LjYwOSwyMzM0LjAxMiwzMjYuNjA5LDIzMzQuMDEyLDMzMC4xMDlMMjMzNC4wMTIsMzMzLjYwOSIvPjxwYXRoIG1hcmtlci1lbmQ9InVybCgjbXktc3ZnX2Zsb3djaGFydC12Mi1wb2ludEVuZCkiIHN0eWxlPSIiIGNsYXNzPSJlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZmxvd2NoYXJ0LWxpbmsiIGlkPSJMX0NfSF8wIiBkPSJNMTcxLjc3MiwzOTEuNjA5TDE2MS4zOTksMzk1Ljc3NkMxNTEuMDI1LDM5OS45NDMsMTMwLjI3OCw0MDguMjc2LDExOS45MDUsNDE1Ljk0M0MxMDkuNTMxLDQyMy42MDksMTA5LjUzMSw0MzAuNjA5LDEwOS41MzEsNDM0LjEwOUwxMDkuNTMxLDQzNy42MDkiLz48cGF0aCBtYXJrZXItZW5kPSJ1cmwoI215LXN2Z19mbG93Y2hhcnQtdjItcG9pbnRFbmQpIiBzdHlsZT0iIiBjbGFzcz0iZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGZsb3djaGFydC1saW5rIiBpZD0iTF9DX0lfMCIgZD0iTTMwNi4yMTIsMzkxLjYwOUwzMTYuNTg2LDM5NS43NzZDMzI2Ljk1OSwzOTkuOTQzLDM0Ny43MDYsNDA4LjI3NiwzNTguMDgsNDE1Ljk0M0MzNjguNDUzLDQyMy42MDksMzY4LjQ1Myw0MzAuNjA5LDM2OC40NTMsNDM0LjEwOUwzNjguNDUzLDQzNy42MDkiLz48cGF0aCBtYXJrZXItZW5kPSJ1cmwoI215LXN2Z19mbG93Y2hhcnQtdjItcG9pbnRFbmQpIiBzdHlsZT0iIiBjbGFzcz0iZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGZsb3djaGFydC1saW5rIiBpZD0iTF9EX0pfMCIgZD0iTTc1MS44OTEsMzg0LjIxTDcyNy45MzEsMzg5LjYxQzcwMy45NzEsMzk1LjAxLDY1Ni4wNTIsNDA1LjgxLDYzMi4wOTIsNDE0LjcwOUM2MDguMTMzLDQyMy42MDksNjA4LjEzMyw0MzAuNjA5LDYwOC4xMzMsNDM0LjEwOUw2MDguMTMzLDQzNy42MDkiLz48cGF0aCBtYXJrZXItZW5kPSJ1cmwoI215LXN2Z19mbG93Y2hhcnQtdjItcG9pbnRFbmQpIiBzdHlsZT0iIiBjbGFzcz0iZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGZsb3djaGFydC1saW5rIiBpZD0iTF9EX0tfMCIgZD0iTTgzOC44NTksMzkxLjYwOUw4MzguODU5LDM5NS43NzZDODM4Ljg1OSwzOTkuOTQzLDgzOC44NTksNDA4LjI3Niw4MzguODU5LDQxNS45NDNDODM4Ljg1OSw0MjMuNjA5LDgzOC44NTksNDMwLjYwOSw4MzguODU5LDQzNC4xMDlMODM4Ljg1OSw0MzcuNjA5Ii8+PHBhdGggbWFya2VyLWVuZD0idXJsKCNteS1zdmdfZmxvd2NoYXJ0LXYyLXBvaW50RW5kKSIgc3R5bGU9IiIgY2xhc3M9ImVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBmbG93Y2hhcnQtbGluayIgaWQ9IkxfRF9MXzAiIGQ9Ik05MjUuODI4LDM4Mi45OUw5NTIuMzQsMzg4LjU5M0M5NzguODUyLDM5NC4xOTcsMTAzMS44NzUsNDA1LjQwMywxMDU4LjM4Nyw0MTQuNTA2QzEwODQuODk4LDQyMy42MDksMTA4NC44OTgsNDMwLjYwOSwxMDg0Ljg5OCw0MzQuMTA5TDEwODQuODk4LDQzNy42MDkiLz48cGF0aCBtYXJrZXItZW5kPSJ1cmwoI215LXN2Z19mbG93Y2hhcnQtdjItcG9pbnRFbmQpIiBzdHlsZT0iIiBjbGFzcz0iZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGZsb3djaGFydC1saW5rIiBpZD0iTF9FX01fMCIgZD0iTTEzNjguMzksMzkxLjYwOUwxMzU5LjM0LDM5NS43NzZDMTM1MC4yODksMzk5Ljk0MywxMzMyLjE4Nyw0MDguMjc2LDEzMjMuMTM3LDQxNS45NDNDMTMxNC4wODYsNDIzLjYwOSwxMzE0LjA4Niw0MzAuNjA5LDEzMTQuMDg2LDQzNC4xMDlMMTMxNC4wODYsNDM3LjYwOSIvPjxwYXRoIG1hcmtlci1lbmQ9InVybCgjbXktc3ZnX2Zsb3djaGFydC12Mi1wb2ludEVuZCkiIHN0eWxlPSIiIGNsYXNzPSJlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZmxvd2NoYXJ0LWxpbmsiIGlkPSJMX0VfTl8wIiBkPSJNMTQ4NS42ODgsMzkxLjYwOUwxNDk0LjczOSwzOTUuNzc2QzE1MDMuNzg5LDM5OS45NDMsMTUyMS44OTEsNDA4LjI3NiwxNTMwLjk0MSw0MTUuOTQzQzE1MzkuOTkyLDQyMy42MDksMTUzOS45OTIsNDMwLjYwOSwxNTM5Ljk5Miw0MzQuMTA5TDE1MzkuOTkyLDQzNy42MDkiLz48cGF0aCBtYXJrZXItZW5kPSJ1cmwoI215LXN2Z19mbG93Y2hhcnQtdjItcG9pbnRFbmQpIiBzdHlsZT0iIiBjbGFzcz0iZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBlZGdlLXRoaWNrbmVzcy1ub3JtYWwgZWRnZS1wYXR0ZXJuLXNvbGlkIGZsb3djaGFydC1saW5rIiBpZD0iTF9GX09fMCIgZD0iTTE4MjQuNzkxLDM5MS42MDlMMTgxNS40NTcsMzk1Ljc3NkMxODA2LjEyNCwzOTkuOTQzLDE3ODcuNDU2LDQwOC4yNzYsMTc3OC4xMjMsNDE1Ljk0M0MxNzY4Ljc4OSw0MjMuNjA5LDE3NjguNzg5LDQzMC42MDksMTc2OC43ODksNDM0LjEwOUwxNzY4Ljc4OSw0MzcuNjA5Ii8+PHBhdGggbWFya2VyLWVuZD0idXJsKCNteS1zdmdfZmxvd2NoYXJ0LXYyLXBvaW50RW5kKSIgc3R5bGU9IiIgY2xhc3M9ImVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBmbG93Y2hhcnQtbGluayIgaWQ9IkxfRl9QXzAiIGQ9Ik0xOTQ1Ljc1NiwzOTEuNjA5TDE5NTUuMDg5LDM5NS43NzZDMTk2NC40MjMsMzk5Ljk0MywxOTgzLjA5LDQwOC4yNzYsMTk5Mi40MjQsNDE1Ljk0M0MyMDAxLjc1OCw0MjMuNjA5LDIwMDEuNzU4LDQzMC42MDksMjAwMS43NTgsNDM0LjEwOUwyMDAxLjc1OCw0MzcuNjA5Ii8+PHBhdGggbWFya2VyLWVuZD0idXJsKCNteS1zdmdfZmxvd2NoYXJ0LXYyLXBvaW50RW5kKSIgc3R5bGU9IiIgY2xhc3M9ImVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBmbG93Y2hhcnQtbGluayIgaWQ9IkxfR19RXzAiIGQ9Ik0yMjgxLjYyNCwzOTEuNjA5TDIyNzMuNTQsMzk1Ljc3NkMyMjY1LjQ1NSwzOTkuOTQzLDIyNDkuMjg2LDQwOC4yNzYsMjI0MS4yMDIsNDE1Ljk0M0MyMjMzLjExNyw0MjMuNjA5LDIyMzMuMTE3LDQzMC42MDksMjIzMy4xMTcsNDM0LjEwOUwyMjMzLjExNyw0MzcuNjA5Ii8+PHBhdGggbWFya2VyLWVuZD0idXJsKCNteS1zdmdfZmxvd2NoYXJ0LXYyLXBvaW50RW5kKSIgc3R5bGU9IiIgY2xhc3M9ImVkZ2UtdGhpY2tuZXNzLW5vcm1hbCBlZGdlLXBhdHRlcm4tc29saWQgZWRnZS10aGlja25lc3Mtbm9ybWFsIGVkZ2UtcGF0dGVybi1zb2xpZCBmbG93Y2hhcnQtbGluayIgaWQ9IkxfR19SXzAiIGQ9Ik0yMzg2LjM5OSwzOTEuNjA5TDIzOTQuNDg0LDM5NS43NzZDMjQwMi41NjgsMzk5Ljk0MywyNDE4LjczNyw0MDguMjc2LDI0MjYuODIyLDQxNS45NDNDMjQzNC45MDYsNDIzLjYwOSwyNDM0LjkwNiw0MzAuNjA5LDI0MzQuOTA2LDQzNC4xMDlMMjQzNC45MDYsNDM3LjYwOSIvPjwvZz48ZyBjbGFzcz0iZWRnZUxhYmVscyI+PGcgY2xhc3M9ImVkZ2VMYWJlbCI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCwgMCkiIGNsYXNzPSJsYWJlbCI+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIwIiB3aWR0aD0iMCI+PGRpdiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgY2xhc3M9ImxhYmVsQmtnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9ImVkZ2VMYWJlbCI+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIGNsYXNzPSJlZGdlTGFiZWwiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAsIDApIiBjbGFzcz0ibGFiZWwiPjxmb3JlaWduT2JqZWN0IGhlaWdodD0iMCIgd2lkdGg9IjAiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIGNsYXNzPSJsYWJlbEJrZyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJlZGdlTGFiZWwiPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyBjbGFzcz0iZWRnZUxhYmVsIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLCAwKSIgY2xhc3M9ImxhYmVsIj48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjAiIHdpZHRoPSIwIj48ZGl2IHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IiBjbGFzcz0ibGFiZWxCa2ciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0iZWRnZUxhYmVsIj48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgY2xhc3M9ImVkZ2VMYWJlbCI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCwgMCkiIGNsYXNzPSJsYWJlbCI+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIwIiB3aWR0aD0iMCI+PGRpdiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgY2xhc3M9ImxhYmVsQmtnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9ImVkZ2VMYWJlbCI+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIGNsYXNzPSJlZGdlTGFiZWwiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAsIDApIiBjbGFzcz0ibGFiZWwiPjxmb3JlaWduT2JqZWN0IGhlaWdodD0iMCIgd2lkdGg9IjAiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIGNsYXNzPSJsYWJlbEJrZyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJlZGdlTGFiZWwiPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyBjbGFzcz0iZWRnZUxhYmVsIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLCAwKSIgY2xhc3M9ImxhYmVsIj48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjAiIHdpZHRoPSIwIj48ZGl2IHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IiBjbGFzcz0ibGFiZWxCa2ciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0iZWRnZUxhYmVsIj48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgY2xhc3M9ImVkZ2VMYWJlbCI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCwgMCkiIGNsYXNzPSJsYWJlbCI+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIwIiB3aWR0aD0iMCI+PGRpdiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgY2xhc3M9ImxhYmVsQmtnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9ImVkZ2VMYWJlbCI+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIGNsYXNzPSJlZGdlTGFiZWwiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAsIDApIiBjbGFzcz0ibGFiZWwiPjxmb3JlaWduT2JqZWN0IGhlaWdodD0iMCIgd2lkdGg9IjAiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIGNsYXNzPSJsYWJlbEJrZyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJlZGdlTGFiZWwiPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyBjbGFzcz0iZWRnZUxhYmVsIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLCAwKSIgY2xhc3M9ImxhYmVsIj48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjAiIHdpZHRoPSIwIj48ZGl2IHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IiBjbGFzcz0ibGFiZWxCa2ciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0iZWRnZUxhYmVsIj48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgY2xhc3M9ImVkZ2VMYWJlbCI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCwgMCkiIGNsYXNzPSJsYWJlbCI+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIwIiB3aWR0aD0iMCI+PGRpdiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgY2xhc3M9ImxhYmVsQmtnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9ImVkZ2VMYWJlbCI+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIGNsYXNzPSJlZGdlTGFiZWwiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAsIDApIiBjbGFzcz0ibGFiZWwiPjxmb3JlaWduT2JqZWN0IGhlaWdodD0iMCIgd2lkdGg9IjAiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIGNsYXNzPSJsYWJlbEJrZyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJlZGdlTGFiZWwiPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyBjbGFzcz0iZWRnZUxhYmVsIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLCAwKSIgY2xhc3M9ImxhYmVsIj48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjAiIHdpZHRoPSIwIj48ZGl2IHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IiBjbGFzcz0ibGFiZWxCa2ciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0iZWRnZUxhYmVsIj48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgY2xhc3M9ImVkZ2VMYWJlbCI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCwgMCkiIGNsYXNzPSJsYWJlbCI+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIwIiB3aWR0aD0iMCI+PGRpdiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgY2xhc3M9ImxhYmVsQmtnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9ImVkZ2VMYWJlbCI+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIGNsYXNzPSJlZGdlTGFiZWwiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAsIDApIiBjbGFzcz0ibGFiZWwiPjxmb3JlaWduT2JqZWN0IGhlaWdodD0iMCIgd2lkdGg9IjAiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIGNsYXNzPSJsYWJlbEJrZyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJlZGdlTGFiZWwiPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyBjbGFzcz0iZWRnZUxhYmVsIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgwLCAwKSIgY2xhc3M9ImxhYmVsIj48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjAiIHdpZHRoPSIwIj48ZGl2IHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IiBjbGFzcz0ibGFiZWxCa2ciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0iZWRnZUxhYmVsIj48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgY2xhc3M9ImVkZ2VMYWJlbCI+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMCwgMCkiIGNsYXNzPSJsYWJlbCI+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIwIiB3aWR0aD0iMCI+PGRpdiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgY2xhc3M9ImxhYmVsQmtnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9ImVkZ2VMYWJlbCI+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIGNsYXNzPSJlZGdlTGFiZWwiPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAsIDApIiBjbGFzcz0ibGFiZWwiPjxmb3JlaWduT2JqZWN0IGhlaWdodD0iMCIgd2lkdGg9IjAiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIGNsYXNzPSJsYWJlbEJrZyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJlZGdlTGFiZWwiPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48L2c+PGcgY2xhc3M9Im5vZGVzIj48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxNDI3LjAzOTA2MjUsIDM1KSIgaWQ9ImZsb3djaGFydC1BLTAiIGNsYXNzPSJub2RlIGRlZmF1bHQiPjxyZWN0IGhlaWdodD0iNTQiIHdpZHRoPSIxODkuOTM3NSIgeT0iLTI3IiB4PSItOTQuOTY4NzUiIHN0eWxlPSJmaWxsOiNmZmViZWUgIWltcG9ydGFudCIgY2xhc3M9ImJhc2ljIGxhYmVsLWNvbnRhaW5lciIvPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC02NC45Njg3NSwgLTEyKSIgc3R5bGU9IiIgY2xhc3M9ImxhYmVsIj48cmVjdC8+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIyNCIgd2lkdGg9IjEyOS45Mzc1Ij48ZGl2IHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9Im5vZGVMYWJlbCI+PHA+SXNzdWUgRW5jb3VudGVyZWQ8L3A+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE0MjcuMDM5MDYyNSwgMTk5LjgwNDY4NzUpIiBpZD0iZmxvd2NoYXJ0LUItMSIgY2xhc3M9Im5vZGUgZGVmYXVsdCI+PHBvbHlnb24gdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTg3LjgwNDY4NzUsODcuODA0Njg3NSkiIGNsYXNzPSJsYWJlbC1jb250YWluZXIiIHBvaW50cz0iODcuODA0Njg3NSwwIDE3NS42MDkzNzUsLTg3LjgwNDY4NzUgODcuODA0Njg3NSwtMTc1LjYwOTM3NSAwLC04Ny44MDQ2ODc1Ii8+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTYwLjgwNDY4NzUsIC0xMikiIHN0eWxlPSIiIGNsYXNzPSJsYWJlbCI+PHJlY3QvPjxmb3JlaWduT2JqZWN0IGhlaWdodD0iMjQiIHdpZHRoPSIxMjEuNjA5Mzc1Ij48ZGl2IHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9Im5vZGVMYWJlbCI+PHA+VHlwZSBvZiBQcm9ibGVtPzwvcD48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjM4Ljk5MjE4NzUsIDM2NC42MDkzNzUpIiBpZD0iZmxvd2NoYXJ0LUMtMyIgY2xhc3M9Im5vZGUgZGVmYXVsdCI+PHJlY3QgaGVpZ2h0PSI1NCIgd2lkdGg9IjE4Ni42NzE4NzUiIHk9Ii0yNyIgeD0iLTkzLjMzNTkzNzUiIHN0eWxlPSIiIGNsYXNzPSJiYXNpYyBsYWJlbC1jb250YWluZXIiLz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtNjMuMzM1OTM3NSwgLTEyKSIgc3R5bGU9IiIgY2xhc3M9ImxhYmVsIj48cmVjdC8+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIyNCIgd2lkdGg9IjEyNi42NzE4NzUiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0ibm9kZUxhYmVsIj48cD5JbnN0YWxsYXRpb24gSXNzdWVzPC9wPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSg4MzguODU5Mzc1LCAzNjQuNjA5Mzc1KSIgaWQ9ImZsb3djaGFydC1ELTUiIGNsYXNzPSJub2RlIGRlZmF1bHQiPjxyZWN0IGhlaWdodD0iNTQiIHdpZHRoPSIxNzMuOTM3NSIgeT0iLTI3IiB4PSItODYuOTY4NzUiIHN0eWxlPSIiIGNsYXNzPSJiYXNpYyBsYWJlbC1jb250YWluZXIiLz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtNTYuOTY4NzUsIC0xMikiIHN0eWxlPSIiIGNsYXNzPSJsYWJlbCI+PHJlY3QvPjxmb3JlaWduT2JqZWN0IGhlaWdodD0iMjQiIHdpZHRoPSIxMTMuOTM3NSI+PGRpdiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJub2RlTGFiZWwiPjxwPkZpbGUvRGF0YSBJc3N1ZXM8L3A+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDE0MjcuMDM5MDYyNSwgMzY0LjYwOTM3NSkiIGlkPSJmbG93Y2hhcnQtRS03IiBjbGFzcz0ibm9kZSBkZWZhdWx0Ij48cmVjdCBoZWlnaHQ9IjU0IiB3aWR0aD0iMTk3LjA5Mzc1IiB5PSItMjciIHg9Ii05OC41NDY4NzUiIHN0eWxlPSIiIGNsYXNzPSJiYXNpYyBsYWJlbC1jb250YWluZXIiLz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtNjguNTQ2ODc1LCAtMTIpIiBzdHlsZT0iIiBjbGFzcz0ibGFiZWwiPjxyZWN0Lz48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjI0IiB3aWR0aD0iMTM3LjA5Mzc1Ij48ZGl2IHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9Im5vZGVMYWJlbCI+PHA+UGVyZm9ybWFuY2UgSXNzdWVzPC9wPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxODg1LjI3MzQzNzUsIDM2NC42MDkzNzUpIiBpZD0iZmxvd2NoYXJ0LUYtOSIgY2xhc3M9Im5vZGUgZGVmYXVsdCI+PHJlY3QgaGVpZ2h0PSI1NCIgd2lkdGg9IjE1Ni4wNDY4NzUiIHk9Ii0yNyIgeD0iLTc4LjAyMzQzNzUiIHN0eWxlPSIiIGNsYXNzPSJiYXNpYyBsYWJlbC1jb250YWluZXIiLz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtNDguMDIzNDM3NSwgLTEyKSIgc3R5bGU9IiIgY2xhc3M9ImxhYmVsIj48cmVjdC8+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIyNCIgd2lkdGg9Ijk2LjA0Njg3NSI+PGRpdiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJub2RlTGFiZWwiPjxwPk91dHB1dCBJc3N1ZXM8L3A+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDIzMzQuMDExNzE4NzUsIDM2NC42MDkzNzUpIiBpZD0iZmxvd2NoYXJ0LUctMTEiIGNsYXNzPSJub2RlIGRlZmF1bHQiPjxyZWN0IGhlaWdodD0iNTQiIHdpZHRoPSIxOTYuNTMxMjUiIHk9Ii0yNyIgeD0iLTk4LjI2NTYyNSIgc3R5bGU9IiIgY2xhc3M9ImJhc2ljIGxhYmVsLWNvbnRhaW5lciIvPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC02OC4yNjU2MjUsIC0xMikiIHN0eWxlPSIiIGNsYXNzPSJsYWJlbCI+PHJlY3QvPjxmb3JlaWduT2JqZWN0IGhlaWdodD0iMjQiIHdpZHRoPSIxMzYuNTMxMjUiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0ibm9kZUxhYmVsIj48cD5FbnZpcm9ubWVudCBJc3N1ZXM8L3A+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDEwOS41MzEyNSwgNDY4LjYwOTM3NSkiIGlkPSJmbG93Y2hhcnQtSC0xMyIgY2xhc3M9Im5vZGUgZGVmYXVsdCI+PHJlY3QgaGVpZ2h0PSI1NCIgd2lkdGg9IjIwMy4wNjI1IiB5PSItMjciIHg9Ii0xMDEuNTMxMjUiIHN0eWxlPSJmaWxsOiNlOGY1ZTggIWltcG9ydGFudCIgY2xhc3M9ImJhc2ljIGxhYmVsLWNvbnRhaW5lciIvPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC03MS41MzEyNSwgLTEyKSIgc3R5bGU9IiIgY2xhc3M9ImxhYmVsIj48cmVjdC8+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIyNCIgd2lkdGg9IjE0My4wNjI1Ij48ZGl2IHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9Im5vZGVMYWJlbCI+PHA+UGFja2FnZSBJbnN0YWxsYXRpb248L3A+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDM2OC40NTMxMjUsIDQ2OC42MDkzNzUpIiBpZD0iZmxvd2NoYXJ0LUktMTUiIGNsYXNzPSJub2RlIGRlZmF1bHQiPjxyZWN0IGhlaWdodD0iNTQiIHdpZHRoPSIyMTQuNzgxMjUiIHk9Ii0yNyIgeD0iLTEwNy4zOTA2MjUiIHN0eWxlPSJmaWxsOiNlOGY1ZTggIWltcG9ydGFudCIgY2xhc3M9ImJhc2ljIGxhYmVsLWNvbnRhaW5lciIvPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC03Ny4zOTA2MjUsIC0xMikiIHN0eWxlPSIiIGNsYXNzPSJsYWJlbCI+PHJlY3QvPjxmb3JlaWduT2JqZWN0IGhlaWdodD0iMjQiIHdpZHRoPSIxNTQuNzgxMjUiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0ibm9kZUxhYmVsIj48cD5EZXBlbmRlbmN5IENvbmZsaWN0czwvcD48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNjA4LjEzMjgxMjUsIDQ2OC42MDkzNzUpIiBpZD0iZmxvd2NoYXJ0LUotMTciIGNsYXNzPSJub2RlIGRlZmF1bHQiPjxyZWN0IGhlaWdodD0iNTQiIHdpZHRoPSIxNjQuNTc4MTI1IiB5PSItMjciIHg9Ii04Mi4yODkwNjI1IiBzdHlsZT0iZmlsbDojZmZmM2UwICFpbXBvcnRhbnQiIGNsYXNzPSJiYXNpYyBsYWJlbC1jb250YWluZXIiLz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtNTIuMjg5MDYyNSwgLTEyKSIgc3R5bGU9IiIgY2xhc3M9ImxhYmVsIj48cmVjdC8+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIyNCIgd2lkdGg9IjEwNC41NzgxMjUiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0ibm9kZUxhYmVsIj48cD5GaWxlIE5vdCBGb3VuZDwvcD48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoODM4Ljg1OTM3NSwgNDY4LjYwOTM3NSkiIGlkPSJmbG93Y2hhcnQtSy0xOSIgY2xhc3M9Im5vZGUgZGVmYXVsdCI+PHJlY3QgaGVpZ2h0PSI1NCIgd2lkdGg9IjE5Ni44NzUiIHk9Ii0yNyIgeD0iLTk4LjQzNzUiIHN0eWxlPSJmaWxsOiNmZmYzZTAgIWltcG9ydGFudCIgY2xhc3M9ImJhc2ljIGxhYmVsLWNvbnRhaW5lciIvPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC02OC40Mzc1LCAtMTIpIiBzdHlsZT0iIiBjbGFzcz0ibGFiZWwiPjxyZWN0Lz48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjI0IiB3aWR0aD0iMTM2Ljg3NSI+PGRpdiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJub2RlTGFiZWwiPjxwPkRlbGltaXRlciBQcm9ibGVtczwvcD48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMTA4NC44OTg0Mzc1LCA0NjguNjA5Mzc1KSIgaWQ9ImZsb3djaGFydC1MLTIxIiBjbGFzcz0ibm9kZSBkZWZhdWx0Ij48cmVjdCBoZWlnaHQ9IjU0IiB3aWR0aD0iMTk1LjIwMzEyNSIgeT0iLTI3IiB4PSItOTcuNjAxNTYyNSIgc3R5bGU9ImZpbGw6I2ZmZjNlMCAhaW1wb3J0YW50IiBjbGFzcz0iYmFzaWMgbGFiZWwtY29udGFpbmVyIi8+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTY3LjYwMTU2MjUsIC0xMikiIHN0eWxlPSIiIGNsYXNzPSJsYWJlbCI+PHJlY3QvPjxmb3JlaWduT2JqZWN0IGhlaWdodD0iMjQiIHdpZHRoPSIxMzUuMjAzMTI1Ij48ZGl2IHN0eWxlPSJkaXNwbGF5OiB0YWJsZS1jZWxsOyB3aGl0ZS1zcGFjZTogbm93cmFwOyBsaW5lLWhlaWdodDogMS41OyBtYXgtd2lkdGg6IDIwMHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCI+PHNwYW4gY2xhc3M9Im5vZGVMYWJlbCI+PHA+RGF0YSBGb3JtYXQgSXNzdWVzPC9wPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxMzE0LjA4NTkzNzUsIDQ2OC42MDkzNzUpIiBpZD0iZmxvd2NoYXJ0LU0tMjMiIGNsYXNzPSJub2RlIGRlZmF1bHQiPjxyZWN0IGhlaWdodD0iNTQiIHdpZHRoPSIxNjMuMTcxODc1IiB5PSItMjciIHg9Ii04MS41ODU5Mzc1IiBzdHlsZT0iZmlsbDojZjNlNWY1ICFpbXBvcnRhbnQiIGNsYXNzPSJiYXNpYyBsYWJlbC1jb250YWluZXIiLz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtNTEuNTg1OTM3NSwgLTEyKSIgc3R5bGU9IiIgY2xhc3M9ImxhYmVsIj48cmVjdC8+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIyNCIgd2lkdGg9IjEwMy4xNzE4NzUiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0ibm9kZUxhYmVsIj48cD5NZW1vcnkgRXJyb3JzPC9wPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxNTM5Ljk5MjE4NzUsIDQ2OC42MDkzNzUpIiBpZD0iZmxvd2NoYXJ0LU4tMjUiIGNsYXNzPSJub2RlIGRlZmF1bHQiPjxyZWN0IGhlaWdodD0iNTQiIHdpZHRoPSIxODguNjQwNjI1IiB5PSItMjciIHg9Ii05NC4zMjAzMTI1IiBzdHlsZT0iZmlsbDojZjNlNWY1ICFpbXBvcnRhbnQiIGNsYXNzPSJiYXNpYyBsYWJlbC1jb250YWluZXIiLz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtNjQuMzIwMzEyNSwgLTEyKSIgc3R5bGU9IiIgY2xhc3M9ImxhYmVsIj48cmVjdC8+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIyNCIgd2lkdGg9IjEyOC42NDA2MjUiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0ibm9kZUxhYmVsIj48cD5TbG93IFBlcmZvcm1hbmNlPC9wPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgxNzY4Ljc4OTA2MjUsIDQ2OC42MDkzNzUpIiBpZD0iZmxvd2NoYXJ0LU8tMjciIGNsYXNzPSJub2RlIGRlZmF1bHQiPjxyZWN0IGhlaWdodD0iNTQiIHdpZHRoPSIxNjguOTUzMTI1IiB5PSItMjciIHg9Ii04NC40NzY1NjI1IiBzdHlsZT0iZmlsbDojZTNmMmZkICFpbXBvcnRhbnQiIGNsYXNzPSJiYXNpYyBsYWJlbC1jb250YWluZXIiLz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtNTQuNDc2NTYyNSwgLTEyKSIgc3R5bGU9IiIgY2xhc3M9ImxhYmVsIj48cmVjdC8+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIyNCIgd2lkdGg9IjEwOC45NTMxMjUiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0ibm9kZUxhYmVsIj48cD5NaXNzaW5nIFJlcG9ydHM8L3A+PC9zcGFuPjwvZGl2PjwvZm9yZWlnbk9iamVjdD48L2c+PC9nPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKDIwMDEuNzU3ODEyNSwgNDY4LjYwOTM3NSkiIGlkPSJmbG93Y2hhcnQtUC0yOSIgY2xhc3M9Im5vZGUgZGVmYXVsdCI+PHJlY3QgaGVpZ2h0PSI1NCIgd2lkdGg9IjE5Ni45ODQzNzUiIHk9Ii0yNyIgeD0iLTk4LjQ5MjE4NzUiIHN0eWxlPSJmaWxsOiNlM2YyZmQgIWltcG9ydGFudCIgY2xhc3M9ImJhc2ljIGxhYmVsLWNvbnRhaW5lciIvPjxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC02OC40OTIxODc1LCAtMTIpIiBzdHlsZT0iIiBjbGFzcz0ibGFiZWwiPjxyZWN0Lz48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjI0IiB3aWR0aD0iMTM2Ljk4NDM3NSI+PGRpdiBzdHlsZT0iZGlzcGxheTogdGFibGUtY2VsbDsgd2hpdGUtc3BhY2U6IG5vd3JhcDsgbGluZS1oZWlnaHQ6IDEuNTsgbWF4LXdpZHRoOiAyMDBweDsgdGV4dC1hbGlnbjogY2VudGVyOyIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwiPjxzcGFuIGNsYXNzPSJub2RlTGFiZWwiPjxwPlZpc3VhbGl6YXRpb24gSXNzdWVzPC9wPjwvc3Bhbj48L2Rpdj48L2ZvcmVpZ25PYmplY3Q+PC9nPjwvZz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgyMjMzLjExNzE4NzUsIDQ2OC42MDkzNzUpIiBpZD0iZmxvd2NoYXJ0LVEtMzEiIGNsYXNzPSJub2RlIGRlZmF1bHQiPjxyZWN0IGhlaWdodD0iNTQiIHdpZHRoPSIxNjUuNzM0Mzc1IiB5PSItMjciIHg9Ii04Mi44NjcxODc1IiBzdHlsZT0iZmlsbDojZmNlNGVjICFpbXBvcnRhbnQiIGNsYXNzPSJiYXNpYyBsYWJlbC1jb250YWluZXIiLz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtNTIuODY3MTg3NSwgLTEyKSIgc3R5bGU9IiIgY2xhc3M9ImxhYmVsIj48cmVjdC8+PGZvcmVpZ25PYmplY3QgaGVpZ2h0PSIyNCIgd2lkdGg9IjEwNS43MzQzNzUiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0ibm9kZUxhYmVsIj48cD5QeXRob24gVmVyc2lvbjwvcD48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjQzNC45MDYyNSwgNDY4LjYwOTM3NSkiIGlkPSJmbG93Y2hhcnQtUi0zMyIgY2xhc3M9Im5vZGUgZGVmYXVsdCI+PHJlY3QgaGVpZ2h0PSI1NCIgd2lkdGg9IjEzNy44NDM3NSIgeT0iLTI3IiB4PSItNjguOTIxODc1IiBzdHlsZT0iZmlsbDojZmNlNGVjICFpbXBvcnRhbnQiIGNsYXNzPSJiYXNpYyBsYWJlbC1jb250YWluZXIiLz48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMzguOTIxODc1LCAtMTIpIiBzdHlsZT0iIiBjbGFzcz0ibGFiZWwiPjxyZWN0Lz48Zm9yZWlnbk9iamVjdCBoZWlnaHQ9IjI0IiB3aWR0aD0iNzcuODQzNzUiPjxkaXYgc3R5bGU9ImRpc3BsYXk6IHRhYmxlLWNlbGw7IHdoaXRlLXNwYWNlOiBub3dyYXA7IGxpbmUtaGVpZ2h0OiAxLjU7IG1heC13aWR0aDogMjAwcHg7IHRleHQtYWxpZ246IGNlbnRlcjsiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sIj48c3BhbiBjbGFzcz0ibm9kZUxhYmVsIj48cD5QYXRoIElzc3VlczwvcD48L3NwYW4+PC9kaXY+PC9mb3JlaWduT2JqZWN0PjwvZz48L2c+PC9nPjwvZz48L2c+PC9zdmc+" alt="Problem Categories" width="600">

## Installation Issues

### Problem: Package Installation Fails

#### Error: `pip install autocsv-profiler` fails

**Common Error Messages:**
```
ERROR: Could not find a version that satisfies the requirement autocsv-profiler
ERROR: No matching distribution found for autocsv-profiler
```

**Solutions:**

1. **Update pip:**
```bash
python -m pip install --upgrade pip
```

2. **Check Python version:**
```bash
python --version
# Should be 3.9 or higher
```

3. **Use specific Python version:**
```bash
python3.11 -m pip install autocsv-profiler
```

4. **Clear pip cache:**
```bash
pip cache purge
pip install autocsv-profiler
```

5. **Use alternative index:**
```bash
pip install -i https://pypi.org/simple/ autocsv-profiler
```

### Problem: Dependency Conflicts

#### Error: Package version conflicts

**Example Error:**
```
ERROR: pip's dependency resolver does not currently consider pre-releases.
ERROR: Cannot install autocsv-profiler because these package versions have conflicting dependencies
```

**Solutions:**

1. **Create fresh virtual environment:**
```bash
python -m venv fresh_env
# Windows:
fresh_env\Scripts\activate
# macOS/Linux:
source fresh_env/bin/activate

pip install autocsv-profiler
```

2. **Update conflicting packages:**
```bash
pip install --upgrade pandas numpy matplotlib seaborn
pip install autocsv-profiler
```

3. **Force reinstall:**
```bash
pip install --force-reinstall autocsv-profiler
```

### Problem: Permission Errors

#### Error: Permission denied during installation

**Solutions:**

1. **User installation:**
```bash
pip install --user autocsv-profiler
```

2. **Virtual environment (recommended):**
```bash
python -m venv csv_env
source csv_env/bin/activate  # Linux/Mac
csv_env\Scripts\activate     # Windows
pip install autocsv-profiler
```

3. **Administrator rights (Windows):**
```cmd
# Run Command Prompt as Administrator
pip install autocsv-profiler
```

## File and Data Issues

### Problem: CSV File Not Found

#### Error: `FileNotFoundError: [Errno 2] No such file or directory`

**Solutions:**

1. **Check file path:**
```bash
# Verify file exists
ls path/to/your/file.csv          # Linux/Mac
dir "path\to\your\file.csv"       # Windows

# Use absolute path
autocsv-profiler /full/path/to/file.csv
```

2. **Check current directory:**
```bash
pwd                               # Linux/Mac
cd                               # Windows

# Navigate to correct directory
cd /path/to/csv/files
autocsv-profiler filename.csv
```

3. **Use quotes for paths with spaces:**
```bash
autocsv-profiler "path with spaces/file name.csv"
```

4. **Check file permissions:**
```bash
ls -la file.csv                  # Linux/Mac
icacls file.csv                  # Windows
```

### Problem: Delimiter Detection Issues

#### Error: Incorrect column parsing or "All data in one column"

**Symptoms:**
- All data appears in a single column
- Column headers not properly recognized
- Data mixed up across columns

**Solutions:**

1. **Manually specify delimiter:**
```bash
# Common delimiters
autocsv-profiler file.csv --delimiter ","    # Comma
autocsv-profiler file.csv --delimiter ";"    # Semicolon  
autocsv-profiler file.csv --delimiter "\t"   # Tab
autocsv-profiler file.csv --delimiter "|"    # Pipe
```

2. **Inspect file manually:**
```bash
# View first few lines
head -5 file.csv                 # Linux/Mac
type file.csv | more             # Windows

# Look for the separator character
```

3. **Test with Python:**
```python
from autocsv_profiler import detect_delimiter

# Test delimiter detection
delimiter = detect_delimiter("problematic_file.csv")
print(f"Detected: '{delimiter}'")

# Manual inspection
with open("problematic_file.csv", 'r') as f:
    first_line = f.readline()
    print(f"First line: {first_line}")
```

4. **Fix the CSV file:**
```python
import pandas as pd

# Read with correct delimiter and save
df = pd.read_csv("file.csv", delimiter=";")
df.to_csv("fixed_file.csv", index=False)
```

### Problem: Data Format Issues

#### Error: Data parsing errors or unexpected data types

**Common Issues:**
- Dates not recognized
- Numbers treated as text
- Special characters causing issues

**Solutions:**

1. **Check file encoding:**
```python
import chardet

# Detect encoding
with open("file.csv", 'rb') as f:
    encoding = chardet.detect(f.read())
    print(f"Detected encoding: {encoding}")

# Read with correct encoding
import pandas as pd
df = pd.read_csv("file.csv", encoding='utf-8')  # or 'latin-1', 'cp1252'
```

2. **Handle special characters:**
```python
# Clean data before analysis
import pandas as pd

df = pd.read_csv("file.csv")

# Remove special characters from numeric columns
numeric_cols = df.select_dtypes(include=['object']).columns
for col in numeric_cols:
    # Remove currency symbols, commas, etc.
    df[col] = df[col].str.replace('$', '').str.replace(',', '')
    
# Try converting to numeric
df[col] = pd.to_numeric(df[col], errors='coerce')

# Save cleaned data
df.to_csv("cleaned_file.csv", index=False)
```

3. **Date format issues:**
```python
import pandas as pd

# Read with date parsing
df = pd.read_csv("file.csv", parse_dates=['date_column'])

# Or manually convert
df['date_column'] = pd.to_datetime(df['date_column'], format='%Y-%m-%d')
```

## Performance Issues

### Problem: Memory Errors

#### Error: `MemoryError` or system becomes unresponsive

**Solutions:**

1. **Check file size:**
```bash
# Check file size
ls -lh file.csv                  # Linux/Mac
dir file.csv                     # Windows

# Files >500MB may cause memory issues
```

2. **Sample large files:**
```python
import pandas as pd

# Create sample for testing
df = pd.read_csv("large_file.csv", nrows=10000)  # First 10,000 rows
df.to_csv("sample_file.csv", index=False)

# Analyze sample first
```

3. **Increase virtual memory (Windows):**
```
Control Panel → System → Advanced → Performance Settings → Advanced → Virtual Memory → Change
Set to "System managed size" or increase manually
```

4. **Monitor memory usage:**
```python
import psutil
import os

# Check available memory
available_gb = psutil.virtual_memory().available / (1024**3)
print(f"Available memory: {available_gb:.1f} GB")

# Monitor during analysis
process = psutil.Process(os.getpid())
memory_mb = process.memory_info().rss / (1024**2)
print(f"Current memory usage: {memory_mb:.1f} MB")
```

5. **Use chunked processing:**
```python
import pandas as pd
from autocsv_profiler import analyze_csv

def analyze_large_file(filename, chunk_size=10000):
    """Analyze large file in chunks"""
    
    # Read file info
    total_rows = sum(1 for line in open(filename)) - 1  # Subtract header
    print(f"Total rows: {total_rows:,}")
    
    if total_rows <= 50000:
        # Small enough to process normally
        analyze_csv(filename, "analysis_output")
    else:
        # Create sample
        sample_size = min(chunk_size, total_rows // 10)
        df_sample = pd.read_csv(filename, nrows=sample_size)
        sample_file = f"sample_{filename}"
        df_sample.to_csv(sample_file, index=False)
        
        print(f"Created sample with {sample_size:,} rows")
        analyze_csv(sample_file, "sample_analysis")

# Usage
analyze_large_file("huge_dataset.csv")
```

### Problem: Slow Performance

#### Issue: Analysis takes too long

**Solutions:**

1. **Profile the analysis:**
```python
import time
from autocsv_profiler import analyze_csv

start_time = time.time()
analyze_csv("file.csv", "output")
elapsed = time.time() - start_time
print(f"Analysis took {elapsed:.1f} seconds")
```

2. **Optimize file size:**
```python
import pandas as pd

# Load and optimize data types
df = pd.read_csv("file.csv")

# Optimize numeric types
for col in df.select_dtypes(include=['int64']).columns:
    df[col] = pd.to_numeric(df[col], downcast='integer')

for col in df.select_dtypes(include=['float64']).columns:
    df[col] = pd.to_numeric(df[col], downcast='float')

# Optimize categorical data
for col in df.select_dtypes(include=['object']).columns:
    if df[col].nunique() < len(df) * 0.5:  # Less than 50% unique values
        df[col] = df[col].astype('category')

# Save optimized file
df.to_csv("optimized_file.csv", index=False)
print(f"File size reduced from {df.memory_usage(deep=True).sum():,} to {df.memory_usage(deep=True).sum():,} bytes")
```

3. **Close other applications:**
```bash
# Free up system resources
# Close unnecessary applications
# Check available memory and CPU
```

## Output Issues

### Problem: Missing or Incomplete Reports

#### Issue: Expected output files not generated

**Solutions:**

1. **Check output directory:**
```bash
# Verify output directory exists and has content
ls -la output_directory/          # Linux/Mac
dir output_directory\             # Windows
```

2. **Check permissions:**
```bash
# Ensure write permissions
chmod 755 output_directory/       # Linux/Mac
icacls output_directory /grant Users:F  # Windows
```

3. **Run with verbose output:**
```python
import logging
from autocsv_profiler import analyze_csv

# Enable debug logging
logging.basicConfig(level=logging.DEBUG)

try:
    analyze_csv("file.csv", "debug_output")
except Exception as e:
    print(f"Error: {e}")
    import traceback
    traceback.print_exc()
```

4. **Check disk space:**
```bash
df -h                             # Linux/Mac  
dir                               # Windows
```

### Problem: Visualization Issues

#### Issue: Plots not displaying or corrupted images

**Solutions:**

1. **Check matplotlib backend:**
```python
import matplotlib
print(f"Backend: {matplotlib.get_backend()}")

# Set backend explicitly
matplotlib.use('Agg')  # Non-interactive backend
```

2. **Verify image files:**
```bash
# Check if image files exist and have content
ls -la output_directory/visualization/  # Linux/Mac
dir output_directory\visualization\     # Windows

# Check file sizes (should not be 0 bytes)
```

3. **Test plotting separately:**
```python
import matplotlib.pyplot as plt
import pandas as pd

# Test basic plotting
df = pd.read_csv("file.csv")
numeric_cols = df.select_dtypes(include=['number']).columns

if len(numeric_cols) > 0:
    plt.figure(figsize=(8, 6))
    plt.hist(df[numeric_cols[0]], bins=20)
    plt.title(f"Histogram of {numeric_cols[0]}")
    plt.savefig("test_plot.png")
    plt.close()
    print("Test plot saved successfully")
```

4. **Update graphics libraries:**
```bash
pip install --upgrade matplotlib seaborn plotly
```

### Problem: HTML Reports Not Opening

#### Issue: Interactive reports show blank pages or errors

**Solutions:**

1. **Try different browsers:**
```bash
# Test with different browsers
chrome report.html
firefox report.html
edge report.html
```

2. **Check JavaScript:**
```javascript
// Open browser console (F12) and check for errors
// Enable JavaScript if disabled
```

3. **Local file restrictions:**
```bash
# For Chrome, start with local file access
chrome --allow-file-access-from-files report.html

# Or serve via local web server
python -m http.server 8000
# Then open http://localhost:8000/report.html
```

4. **File size issues:**
```bash
# Check if HTML file is too large
ls -lh report.html               # Linux/Mac
dir report.html                  # Windows

# If >50MB, the file may be too large for browsers
```

## Environment Issues

### Problem: Python Version Issues

#### Error: Incompatible Python version

**Solutions:**

1. **Check Python version:**
```bash
python --version
python3 --version

# Should be 3.9 or higher
```

2. **Install compatible Python:**
```bash
# Using pyenv (Linux/Mac)
pyenv install 3.11.0
pyenv global 3.11.0

# Using Anaconda
conda install python=3.11
```

3. **Use specific Python version:**
```bash
# Use specific Python executable
python3.11 -m pip install autocsv-profiler
python3.11 -c "from autocsv_profiler import analyze_csv; analyze_csv('file.csv', 'output')"
```

### Problem: Path and Environment Issues

#### Issue: Command not found or import errors

**Solutions:**

1. **Check PATH:**
```bash
# Check if Python scripts directory is in PATH
echo $PATH                       # Linux/Mac
echo %PATH%                      # Windows

# Find where autocsv-profiler is installed
which autocsv-profiler           # Linux/Mac
where autocsv-profiler           # Windows
```

2. **Add to PATH:**
```bash
# Linux/Mac (add to ~/.bashrc or ~/.zshrc)
export PATH="$HOME/.local/bin:$PATH"

# Windows (System Properties → Environment Variables)
# Add Python\Scripts directory to PATH
```

3. **Use full path:**
```bash
# Use full path to executable
/usr/local/bin/autocsv-profiler file.csv
C:\Python311\Scripts\autocsv-profiler.exe file.csv
```

4. **Virtual environment activation:**
```bash
# Ensure virtual environment is activated
source venv/bin/activate         # Linux/Mac
venv\Scripts\activate            # Windows

# Check which Python is active
which python                     # Linux/Mac
where python                     # Windows
```

## Advanced Troubleshooting

### Diagnostic Script

```python
#!/usr/bin/env python3
"""
AutoCSV Profiler Diagnostic Script
Run this to diagnose common issues
"""

import sys
import os
import subprocess
import platform

def run_diagnostics():
    """Run comprehensive diagnostics"""
    
    print("AutoCSV Profiler Diagnostic Report")
    print("=" * 40)
    
    # System information
    print(f"\nSystem Information:")
    print(f"OS: {platform.system()} {platform.release()}")
    print(f"Python: {sys.version}")
    print(f"Platform: {platform.platform()}")
    
    # Python environment
    print(f"\nPython Environment:")
    print(f"Executable: {sys.executable}")
    print(f"Path: {sys.path[0]}")
    
    # Package versions
    print(f"\nPackage Versions:")
    packages = [
        'autocsv_profiler', 'pandas', 'numpy', 'matplotlib', 
        'seaborn', 'scipy', 'sklearn', 'statsmodels'
    ]
    
    for package in packages:
        try:
            module = __import__(package)
            version = getattr(module, '__version__', 'Unknown')
            print(f"{package}: {version}")
        except ImportError:
            print(f"{package}: Not installed")
    
    # Memory and disk space
    try:
        import psutil
        memory = psutil.virtual_memory()
        disk = psutil.disk_usage('.')
        
        print(f"\nSystem Resources:")
        print(f"Total Memory: {memory.total / (1024**3):.1f} GB")
        print(f"Available Memory: {memory.available / (1024**3):.1f} GB")
        print(f"Disk Free: {disk.free / (1024**3):.1f} GB")
    except ImportError:
        print(f"\nSystem Resources: psutil not available")
    
    # Test basic functionality
    print(f"\nFunctionality Tests:")
    
    # Test import
    try:
        from autocsv_profiler import analyze_csv, detect_delimiter
        print("✓ Package import successful")
    except ImportError as e:
        print(f"✗ Package import failed: {e}")
        return
    
    # Test delimiter detection
    try:
        # Create test file
        test_data = "name,age,city\nAlice,25,NYC\nBob,30,LA"
        with open("test.csv", "w") as f:
            f.write(test_data)
        
        delimiter = detect_delimiter("test.csv")
        print(f"✓ Delimiter detection successful: '{delimiter}'")
        
        # Clean up
        os.remove("test.csv")
    except Exception as e:
        print(f"✗ Delimiter detection failed: {e}")
    
    # Test analysis (with small dataset)
    try:
        # Create test dataset
        test_data = """name,age,salary,department
Alice Johnson,28,65000,Engineering
Bob Smith,34,72000,Marketing
Carol Davis,29,58000,Sales"""
        
        with open("diagnostic_test.csv", "w") as f:
            f.write(test_data)
        
        analyze_csv("diagnostic_test.csv", "diagnostic_output")
        
        # Check if output was created
        if os.path.exists("diagnostic_output"):
            output_files = os.listdir("diagnostic_output")
            print(f"✓ Analysis successful: {len(output_files)} files generated")
            
            # Clean up
            import shutil
            shutil.rmtree("diagnostic_output")
        else:
            print("✗ Analysis failed: No output generated")
        
        os.remove("diagnostic_test.csv")
        
    except Exception as e:
        print(f"✗ Analysis test failed: {e}")
    
    print(f"\nDiagnostic complete!")
    print(f"If issues persist, please share this report when seeking help.")

if __name__ == "__main__":
    run_diagnostics()
```

Save this as `diagnostic.py` and run with:
```bash
python diagnostic.py
```

### Performance Monitoring

```python
import time
import psutil
import os
from autocsv_profiler import analyze_csv

def monitored_analysis(csv_file, output_dir):
    """Run analysis with performance monitoring"""
    
    process = psutil.Process(os.getpid())
    
    # Initial state
    start_time = time.time()
    start_memory = process.memory_info().rss / (1024**2)  # MB
    
    print(f"Starting analysis of {csv_file}")
    print(f"Initial memory: {start_memory:.1f} MB")
    
    try:
        # Run analysis
        analyze_csv(csv_file, output_dir)
        
        # Final state
        end_time = time.time()
        end_memory = process.memory_info().rss / (1024**2)  # MB
        
        elapsed = end_time - start_time
        memory_used = end_memory - start_memory
        
        print(f"Analysis completed successfully!")
        print(f"Time elapsed: {elapsed:.1f} seconds")
        print(f"Memory used: {memory_used:.1f} MB")
        print(f"Peak memory: {end_memory:.1f} MB")
        
        # Check output
        if os.path.exists(output_dir):
            files = os.listdir(output_dir)
            print(f"Generated {len(files)} output files")
        
    except Exception as e:
        end_time = time.time()
        end_memory = process.memory_info().rss / (1024**2)
        
        print(f"Analysis failed after {end_time - start_time:.1f} seconds")
        print(f"Memory at failure: {end_memory:.1f} MB")
        print(f"Error: {e}")
        
        import traceback
        traceback.print_exc()

# Usage
monitored_analysis("your_file.csv", "monitored_output")
```

## Getting Additional Help

### When to Seek Help

1. **After trying solutions in this guide**
2. **Error persists across different files**
3. **System-specific issues**
4. **Performance problems with reasonable datasets**

### How to Report Issues

#### Information to Include

1. **System Information:**
   - Operating system and version
   - Python version (`python --version`)
   - AutoCSV Profiler version
   - Installation method (pip, conda, source)

2. **Error Details:**
   - Complete error message
   - Steps to reproduce
   - Sample data (anonymized if needed)
   - Command or code that caused the error

3. **Environment:**
   - Virtual environment details
   - Other installed packages (`pip list`)
   - Available memory and disk space

#### Example Issue Report

```
Title: MemoryError with 100MB CSV file

Environment:
- OS: Windows 11
- Python: 3.11.2  
- AutoCSV Profiler: 1.1.0
- RAM: 8GB
- Installation: pip install autocsv-profiler

Issue:
Getting MemoryError when analyzing a 100MB CSV file with 500k rows and 25 columns.

Error Message:
MemoryError: Unable to allocate array with shape (500000, 25) and data type float64

Steps to Reproduce:
1. autocsv-profiler large_dataset.csv
2. Error occurs during statistical analysis phase

Sample Data:
File has mixed data types - 15 numeric columns, 10 categorical columns
No obvious data quality issues
Delimiter: comma

Already Tried:
- Closing other applications
- Using virtual environment
- Sampling first 10k rows (works fine)
```

### Support Channels

- **GitHub Issues**: [Report bugs](https://github.com/dhaneshbb/AutoCSV-Profiler-Suite/issues)
- **Documentation**: [Read docs](https://github.com/dhaneshbb/AutoCSV-Profiler-Suite/tree/main/docs)  
- **Examples**: [Check examples](examples.md)

### Community Guidelines

1. **Search existing issues** before creating new ones
2. **Provide minimal reproducible examples**
3. **Use descriptive titles**
4. **Be respectful and patient**
5. **Help others when you can**

This troubleshooting guide should resolve most common issues. If you encounter problems not covered here, please create an issue on GitHub with detailed information.